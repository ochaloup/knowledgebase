= Effective Java (chapter 9)

:icons: font

icon:bookmark[] https://www.amazon.com/Effective-Java-Joshua-Bloch-ebook/dp/B078H61SCH

icon:tags[] java, programming.language, tips

== Chapter 9: General Programming

Problem: the nuts and bolts of the language

=== Item 57: Why to minimize scope of local variables?

To defend yourself to dumb mistakes, to make the work of GC easier.
As the best strategy declare the local variable where it is first used.

Example of bug

[source,java]
----
Iterator<Element> i = c.iterator();
while(i.hasNext()) {
  doSomething(i.next());
}

Iterator<Element> i2 = c2.iterator();
while(i.hasNext()) { // BUG here!
  doSomething(i2.next());
}
----


=== Item 58: Why to prefere `for-each` loops?

The iterator and the index variables are both just clutter.
There could be a typo easily in the standard loop
as the iterator occurs four times when the loop is constructed.

[source,java]
----
// preferred idiom for iterating over collection
// the ':' is read as "in" aka "for each element e in elements"
for (Element e: elements) {
  doSomething(e);
}
----

Three common situations where `for-each` loop can't be used

* destructive filtering - for deletion the is need to call `iterator.remove()`,
  alternative is to use the
  https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html#removeIf-java.util.function.Predicate-[`Collection#removeIf`]
  method added in Java 8.
* transforming - list traversal with replacing some or all of the values of its elements,
  then iterator or index is needed
* parallel iteration - to traverse multiple collections in parallel then explicit control is needed

NOTE: Any type that represents a group of elements should be considered to implement interface `Iterable`.
      (it's not necessary to be a `Collection`).


=== Item 59: Why to use libraries when possible?

For small common tasks is usual that programmer creates his own method.
That's not a good practice as there could be corner cases which may
not be covered and is better to use specialized function from a common library.

Example of generating random number

[source,java]
----
static Random random = new Random();

static int random(int n) {
  return Math.abs(rnd.nextInt()) % n;
}
----

This is deeply flawed. If `n` is a small power of two, the sequence of random numbers
will repeat itself after a fairluy short period. If `n` is not a power of two,
some numbers will, on average, be returned more frequently. If `nextInt()` returns
`Integer.MIN_VALUE` then `Math.abs` return also `Integer.MIN_VALUE` and the `%`
the returns negative number.

Why not to use a prepared function which does the task correctly -
`Random.nextInt(int)`?

NOTE: as of Java 7, the random number generator of choice is now `ThreadLocalRandom`.
      For fork join pools and parallel streams use `SplittableRandom`.

Programmer should be familiar with baiscs of `java.lang`, `java.util` and `java.io`!

[TIP]
====
How to print content of URL to System out? From Java 9 you can do

[source,java]
----
try(InputStream in = new URL(someUrl)).openStream()) {
  in.transferTo(System.out);
}
----
====


=== Item 60: Where to be careful in using `float` and `double`?

The `float` and `double` are designed for scientific and engineering calculations.
They do not provide exact(**!**) results. Particularly they are ill-suited for monetary
calculations**!**

[source,java]
----
System.out.println(1.03 - 0.42)
// prints out: 0.6100000000000000001
----

For monetary calculation use `BigDecimal`, `int` or `long`.

NOTE: disadvantages for `BigDecimal` are - less convenient than primitive arithmetic type
      and it's slower


=== Item 61: Why to prefer primitive types?

Java has a two-part type system - _primitives_ (`int`, `double`, `boolean`) and _reference types_
(`String`, `List`,...). Every _primitive_ type has a corresponding _reference type_,
called `boxed primitive`. E.g. for `int` it's `Integer` for `boolean` it's `Boolean`.

The process of autoboxing and auto-unboxing blur the distiction between them.
Three main differences

* primitives have only their values, whereas boxed primitives have identities,
  ie. `3 == 3` but `new Integer(3) != new Integer(3)`.
* primitive types have only fully functional values,
  whereas boxed primitive types have one nonfunctional value which is `null`
* primitives are more time- and space-efficient

WARNING: applying the `==` operator to boxed primitives is almost always wrong

Be care of auto-(un)boxed behaviour.

[source,java]
----
public class Unbelievable {
  static Integer i;

  public static main(String[] args) {
    if (i == 42) {
      System.out.println("Unbelievable");
    }
  }
}
----

This code throws `NullPointerException`**!**. The `i` will be auto-unboxed,
but `i` is `null` and equality will throw the exception.

And what about hidden boxing/auto-boxing which slows down the processing. The local variable `sum`
is boxed primitive `Long` which means repeatedly boxed and unboxed operations.

[source,java]
----
Long sum = 0L;
for (long i = 0; i < Integer.MAX_VALUE; i++) {
  sum += i;
}
----

When is legitimate to use boxed primitive types?
As this is not permitted `ThreadLocal<int>`*!*


=== Item 62: Why to avoid using String everywhere?

Strings are poor substitute for other value types!
E.g. why to use this `String compoundKey = className + "#" + i.next()`
when there can't be provided `equals` or `compareTo` methods, the `toString` and others.
The better approach is simply to write a class to represent the aggregate
(often then a private static member class).


=== Item 63: Why string concatenation is slow?

The `String` is immutable. The concetation operator `+` means of creating
new objects repeatedly and the content is copied. For concatenation of two strings
the content of both is copied(**!**) to a new object.

Using the string concatenation operator repeatedly to concatenate _n_ strings
requires time quadratic in _n_.

For repeatable concatenation use `StringBuilder.append` instead.
Use string concatenation only to combine not more than a few strings.
